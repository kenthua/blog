---
author: Kent Hua
blogger_id: tag:blogger.com,1999:blog-3324719914062696225.post-2099795433670538268
blogger_orig_url: http://blog.kenthua.com/2016/04/jboss-bxms-62-updates-and-findings.html
comments: true
date: "2016-04-18T17:15:00Z"
modified_time: "2016-04-19T16:29:19.397-07:00"
tags: null
title: JBoss BxMS 6.2 updates and findings (kie-server & githook)
---

<div><b>kie-server</b></div><div><br /></div>Following my previous post for BRMS kie-server's significant changes from 6.1 to 6.2. &nbsp;I did some additional testing and documented some high level API commands in my github <a href="https://gist.github.com/kenthua/8705ce001dca9f3fba1b40832c3245ab">gist</a>. &nbsp;In BRMS it's the Realtime Decision Server and in BPMS it's the Intelligent Process Server. &nbsp;As with BRMS, it will provide just the runtime environment for rules and processes. &nbsp;There is no business central or design time instance.<br /><div><br /></div><div>The documentation for the API's for both rules and process under <a href="https://access.redhat.com/documentation/en-US/Red_Hat_JBoss_BPM_Suite/6.2/html/User_Guide/realtime_decision_server.html">BPMS</a>.</div><div><br /></div><div>Managed provides a way to define a central controller server (business-central) which is able to manage the state across multiple instances, where as an unmanaged is a standalone instance. &nbsp;Interaction with the unmanaged is only via the API.<br /><br />In a managed scenario, you will need at least one controller already started so that the runtime environments. &nbsp;In a configuration first definition, the following properties need to be set for the controller. &nbsp;From the <a href="https://access.redhat.com/documentation/en-US/Red_Hat_JBoss_BPM_Suite/6.2/html/User_Guide/Realtime_Decision_Server_Setup.html#Registering_a_Decision_Server">documentation</a>. &nbsp;Note the required use of kieserver/kieserver1! for BxMS 6.2.<br /><pre><code class="xml"><br />&lt;property name="org.kie.server.user" value="someusername"&gt;&lt;/property&gt;<br />&lt;property name="org.kie.server.pwd" value="somepassword"&gt;&lt;/property&gt;<br />&lt;property name="org.kie.server.location" value="http://localhost:8080/kie-server/services/rest/server"&gt;&lt;/property&gt;<br />&lt;property name="org.kie.server.controller" value="http://localhost:8080/business-central/rest/controller"&gt;&lt;/property&gt;<br />&lt;property name="org.kie.server.controller.user" value="kieserver"&gt;&lt;/property&gt;<br />&lt;property name="org.kie.server.controller.pwd" value="kieserver1!"&gt;&lt;/property&gt;<br />&lt;property name="org.kie.server.id" value="local-server"&gt;&lt;/property&gt;<br /></code></pre>The appropriate application users 'someusername' and 'kieserver' will need to be created, with at least the 'kie-server' role.<br /><br /><br />The runtime servers only need the kie-server.war. &nbsp;In the case of the runtime server you will need the following system properties.<br /><pre><code class="xml"><br />&lt;property name="org.kie.server.location" value="http://localhost:8180/kie-server/services/rest/server"&gt;&lt;/property&gt; &lt;!-- note this is the runtime server, with a port-offset of 100 --&gt;<br />&lt;property name="org.kie.server.controller" value="http://localhost:8080/business-central/rest/controller"&gt;&lt;/property&gt; &lt;!-- note pointing to your controller server --&gt;<br />&lt;property name="org.kie.server.id" value="local-server"&gt;&lt;/property&gt;<br /></code></pre>For the runtime you just need the application user 'someusername' to be able to authenticate with the runtime kie-server, with the role 'kie-server'</div><div><br /></div><div><br /></div><div><b>githook</b></div><div><br /></div><div>So another new feature in 6.2 is being able to incorporate your design time commits to an enterprise repository. &nbsp;While there were previous methods to do this externally, i.e. (file system change detection, cron job, etc), <a href="https://access.redhat.com/solutions/2137461">there is now a githook option to able to trigger a 'post-commit' script execution</a>. &nbsp;It requires creating the 'post-commit' script as well as making sure your remote server is properly defined in your BxMS niogit repository. &nbsp;So this will make it more straightforward to incorporate the BxMS builds into your automated enterprise build strategy.</div><div><br /></div>